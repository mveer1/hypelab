Newton's Cradle Simulation
Create a JavaScript simulation of Newton's Cradle that demonstrates conservation of momentum and energy through a series of swinging spheres. The simulation should:

Physics Explanation:
Newton's Cradle demonstrates conservation of momentum and energy in a series of swinging spheres. When a number of balls are pulled back and released, the same number of balls on the opposite end are pushed outward to nearly the same height, provided there is negligible air resistance, perfect elasticity, and identical mass and alignment.

Control Parameters:

Number of Balls: Adjust how many balls are present (typically 3–7).
Balls Pulled Back: Select how many balls to lift and release on either side.
Gravity: Change the gravitational acceleration to observe effects on swing period.
Damping/Air Resistance: Adjust to see how real-world losses affect synchronization and energy dissipation.
Elasticity: Set the coefficient of restitution to control how perfectly energy and momentum are transferred in collisions.


Physics Engine Implementation:

Implement accurate ball collision physics using a 2D physics engine like Matter.js

Model elastic collisions between spheres with proper energy and momentum transfer

Create a realistic pendulum motion for each suspended ball

Interactive Features:

Allow users to drag and release any number of balls to set the cradle in motion

Include controls to adjust the number of balls (3-7 balls)

Add functionality to raise balls on either or both sides of the cradle

Implement play, pause, and reset controls

Visualization Components:

Display a real-time graph of potential and kinetic energy for each ball

Show numerical values for momentum, velocity, and energy of each ball

Include a mathematical model section displaying relevant equations:

Conservation of momentum equation

Conservation of energy equation

Equations for calculating ball positions and velocities

Edge Cases:

Handle dissipation effects causing eventual synchronization of all balls

Account for the initial break-up of the line of balls at first collision

Implement realistic viscoelastic dissipation in impacts

Technical Recommendations:

Use Canvas or WebGL for rendering

Consider TypeScript for better code maintainability

Optimize collision detection algorithms for smooth performance

The simulation should educate users about Newton's laws of motion, conservation principles, and demonstrate why the cradle behaves as it does, including explaining why all balls eventually move in phase in real-world applications.

Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.













Harmonic Oscillator Simulation
Create a JavaScript simulation of a harmonic oscillator that demonstrates simple harmonic motion. The simulation should:

Physics Explanation:
This simulates a mass attached to a spring, following Hooke’s Law. The system exhibits simple harmonic motion, with energy oscillating between kinetic and potential forms. Damping can be introduced to show energy loss, and external driving forces can demonstrate resonance.

Control Parameters:

Mass: Change the mass of the oscillating object.

Spring Constant (k): Adjust the stiffness of the spring.

Damping Coefficient: Control the rate at which energy is lost to friction or air resistance.

Initial Displacement/Velocity: Set the starting position and speed of the mass.

Gravity: Modify gravitational acceleration for vertical oscillators.

Drive Frequency/Amplitude: For driven oscillators, set the frequency and strength of the external force.


Physics Implementation:

Model a mass-spring system showing Hooke's Law (F = -kx) in action

Implement differential equations governing simple harmonic motion

Include damping options (undamped, underdamped, critically damped, overdamped)

Interactive Elements:

Allow users to drag the mass to set initial displacement

Include sliders to adjust:

Mass of the object

Spring constant

Damping coefficient

Initial displacement and velocity

Visualization Components:

Display a real-time position vs. time graph

Plot energy transfer between potential and kinetic energy over time

Show phase diagram (position vs. velocity)

Include numerical values for:

Current position, velocity, and acceleration

Period and frequency

Total energy, potential energy, and kinetic energy

Mathematical Section:

Display the equation of motion: m(d²x/dt²) + c(dx/dt) + kx = 0

Show the solution for different damping conditions

Include formula for period: T = 2π√(m/k)

Edge Cases:

Handle resonance phenomena when an external periodic force is applied

Implement energy dissipation in damped scenarios

Allow for driven oscillations with adjustable driving frequency

Technical Recommendations:

Implement using requestAnimationFrame for smooth animation

Use numerical integration methods (Euler or RK4) for solving equations of motion

Consider Canvas API for rendering

The simulation should clearly demonstrate the relationship between force, displacement, and energy in harmonic systems, while providing intuitive controls to explore different oscillatory regimes.

Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.














Quantum Mechanics Simulations
Wave Function Simulation
Create a JavaScript simulation visualizing quantum wave functions and their time evolution. The simulation should:

Physics Explanation:
Visualizes the evolution of a quantum wave function in various potentials using the time-dependent Schrödinger equation. Users can observe phenomena like wave packet spreading, reflection, tunneling, and interference, as well as the probability density associated with particle position.

Control Parameters:

Potential Type & Shape: Select and modify potential wells, barriers, or harmonic potentials.

Particle Mass: Adjust to demonstrate quantum effects for different particles.

Wave Packet Width & Position: Set the initial localization and center of the wave function.

Energy: Adjust the initial energy of the wave packet.

Planck’s Constant (h): Optionally vary to illustrate quantum-to-classical transition.

Boundary Conditions: Choose between infinite, finite, or periodic boundaries.


Physics Implementation:

Solve the time-dependent Schrödinger equation numerically

Implement various potential functions (infinite well, finite well, barrier, harmonic)

Model wave packet dynamics, including spreading, reflection, and tunneling effects

Interactive Features:

Allow users to select different potential configurations

Enable drawing custom potential barriers

Include sliders for adjusting:

Initial wave packet width and position

Energy/momentum of the wave packet

Potential barrier heights and widths

Visualization Components:

Plot real-time wave function amplitude (real and imaginary parts)

Display probability density (|ψ|²) with color intensity

Graph expectation values of position and momentum over time

Show energy spectrum for bound states

Mathematical Section:

Display the Schrödinger equation: iℏ∂ψ/∂t = -ℏ²/2m ∇²ψ + V(x)ψ

Include normalization condition: ∫|ψ|²dx = 1

Show formulas for expectation values and uncertainties

Edge Cases:

Handle boundary conditions correctly

Ensure wave function normalization is preserved during evolution

Implement superposition of eigenstates

Technical Recommendations:

Use WebGL for faster computation and visualization

Implement finite difference method or spectral methods for numerical solutions

Consider Web Workers for intensive calculations to maintain UI responsiveness

The simulation should provide intuitive visualization of quantum mechanical concepts like wave-particle duality, uncertainty principle, and probability interpretation of quantum mechanics.

Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.













Particle in a Box Simulation
Create a JavaScript simulation of the quantum mechanical particle in a box model. The simulation should:

Physics Explanation:
Shows the quantization of energy levels and standing wave patterns for a particle confined in a 1D, 2D, or 3D box. Demonstrates how only certain wave functions and energies are allowed due to boundary conditions.

Control Parameters:

Box Dimensions: Change the size of the box in each direction.

Particle Mass: Adjust to see its effect on energy levels.

Quantum Numbers: Select which energy state(s) to visualize.

Superposition: Combine multiple eigenstates to show interference and time evolution.

Potential Height (for finite wells): Set the depth of the potential walls.


Physics Implementation:

Solve the time-independent Schrödinger equation for confined particles

Implement 1D, 2D, and 3D box configurations

Calculate and display energy eigenstates and eigenfunctions

Interactive Features:

Allow selection of dimensionality (1D, 2D, or 3D)

Include controls to adjust:

Box dimensions

Particle mass

Quantum numbers (n, m for 2D; n, m, l for 3D)

Enable superposition of multiple eigenstates with adjustable coefficients

Visualization Components:

Display wave functions and probability densities in real-time

Show energy level diagram with currently selected states highlighted

Plot time evolution of wave packet superpositions

Include expected position and momentum uncertainties

Mathematical Section:

Display energy quantization formula: En = (n²π²ℏ²)/(2mL²)

Show wave function expressions for different quantum numbers

Include normalization constants and orthogonality relationships

Edge Cases:

Handle transitions between states with animation

Implement finite potential wells with tunneling effects

Account for degeneracy in higher dimensions

Technical Recommendations:

Use WebGL shaders for 2D and 3D visualization

Implement caching of pre-calculated eigenstates for performance

Consider using a physics library specialized in quantum simulations

The simulation should clearly illustrate energy quantization, standing waves, and probability distributions, connecting these quantum concepts to the classical limit for higher quantum numbers.
'

Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.

















Gravity Simulations
Orbital Motion Simulation
Create a JavaScript simulation of gravitational orbital motion. The simulation should:

Physics Explanation:
Simulates the motion of celestial bodies under Newtonian gravity. Users can create multi-body systems, observe elliptical orbits, orbital resonances, and even chaotic trajectories in three-body setups.

Control Parameters:

Number of Bodies: Set how many planets, stars, or asteroids are present.

Masses: Adjust the mass of each body.

Initial Positions & Velocities: Set starting locations and speeds.

Gravitational Constant (G): Modify to explore different gravitational strengths.

Time Scale: Speed up or slow down the simulation for detailed study.

Relativistic Corrections: Optionally enable for high-mass or high-speed scenarios.



Physics Implementation:

Implement Newton's law of universal gravitation

Use numerical integration (Runge-Kutta or Leapfrog method) for solving equations of motion

Enable N-body gravitational interactions for complex systems

Interactive Features:

Allow users to create and place planetary bodies with custom:

Masses

Initial positions

Initial velocities

Enable dragging objects to modify their trajectories

Include time controls (speed up, slow down, pause)

Provide presets for solar system configurations

Visualization Components:

Display orbital paths with trajectory prediction

Plot energy (kinetic, potential, total) over time

Graph orbital parameters (eccentricity, semi-major axis)

Show velocity vectors for each body

Mathematical Section:

Display Newton's law of gravitation: F = G(m₁m₂)/r²

Include Kepler's laws of planetary motion

Show formulas for orbital period, energy, and angular momentum

Edge Cases:

Handle close encounters and collisions between bodies

Implement relativistic corrections for high velocities or strong gravity

Account for three-body problem instabilities

Simulate orbital decay and capture scenarios

Technical Recommendations:

Use Three.js for 3D visualization

Implement adaptive time step for maintaining accuracy during close encounters

Consider WebAssembly for computationally intensive physics calculations

The simulation should educate users about gravitational dynamics, orbital stability, and celestial mechanics, while providing an intuitive interface for exploration.


Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.
























Gravitational Lensing Simulation
Create a JavaScript simulation demonstrating gravitational lensing effects. The simulation should:


Physics Explanation:
Demonstrates how massive objects bend the path of light, creating phenomena like Einstein rings and multiple images. Shows the effect of mass, distance, and alignment on the appearance of background sources.

Control Parameters:

Lens Mass: Adjust the mass of the lensing object.

Lens Position & Distance: Move the lens relative to the observer and background source.

Source Position: Change the location of the background light source.

Lens Profile: Select between point mass, spherical, or extended mass distributions.

Zoom & Field of View: Focus in on lensing effects or view a wider area.



Physics Implementation:

Model light deflection near massive objects using general relativity principles

Implement ray-tracing algorithms to visualize light path curvature

Calculate Einstein radius and magnification factors for different mass distributions

Interactive Features:

Allow placement of massive objects (galaxies, black holes) with adjustable:

Mass

Distance from observer

Distribution profile (point mass, spherical, elliptical)

Enable positioning of background light sources

Include zoom and pan controls for detailed observation

Visualization Components:

Display distorted images of background sources

Show multiple images and Einstein rings where appropriate

Plot magnification as a function of source-lens alignment

Include light ray trajectories through the lens system

Mathematical Section:

Display the lens equation relating source and image positions

Show deflection angle formula: α = 4GM/(c²r)

Include Einstein radius calculation

Edge Cases:

Handle strong lensing with multiple images

Implement microlensing events with time-dependent magnification

Account for extended source effects and caustic crossings

Simulate complex lens systems with multiple lensing objects

Technical Recommendations:

Use WebGL for efficient ray tracing and rendering

Implement adaptive grid resolution for accurate lens modeling

Consider pre-computing deflection maps for performance

The simulation should clearly demonstrate how mass curves spacetime, affecting light paths and creating visual phenomena like Einstein rings, arcs, and multiple images, while providing intuitive understanding of general relativistic effects.

Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.






















Chaos Theory Simulations
Double Pendulum Simulation
Create a JavaScript simulation of a double pendulum system showcasing chaotic dynamics. The simulation should:

Physics Explanation:
A double pendulum consists of one pendulum attached to another. Its motion is highly sensitive to initial conditions, exhibiting chaotic behavior and complex phase space trajectories even with small changes in starting angles or velocities.

Control Parameters:

Masses of Both Bobs: Adjust the mass of each pendulum.

Lengths of Both Arms: Change the length of each pendulum rod.

Initial Angles & Velocities: Set the starting positions and speeds.

Gravity: Modify the gravitational acceleration.

Damping: Add or remove frictional losses.



Physics Implementation:

Derive and solve the coupled differential equations of motion

Use Lagrangian mechanics approach for accurate physics

Implement high-precision numerical integration (4th order Runge-Kutta method)

Interactive Features:

Allow adjustment of:

Masses of both pendulum bobs

Lengths of both arms

Initial angles and angular velocities

Gravity strength

Enable comparison of two pendulums with slightly different initial conditions

Include play, pause, and reset controls

Visualization Components:

Display real-time animation of pendulum motion

Plot phase space trajectories (angles vs. angular velocities)

Graph energy distribution (potential vs. kinetic) over time

Show Lyapunov exponent calculation demonstrating sensitivity to initial conditions

Trace the path of the second pendulum bob

Mathematical Section:

Display the Lagrangian of the system

Show the derived equations of motion

Include energy conservation formula

Display Lyapunov exponent calculation

Edge Cases:

Handle energy conservation in numerical integration

Implement variable time-step for maintaining accuracy during rapid motion

Account for damping effects (air resistance)

Visualize the divergence of nearly identical initial conditions

Technical Recommendations:

Use Canvas or WebGL for rendering

Implement Web Workers for physics calculations to maintain UI responsiveness

Consider using a dedicated differential equation solver library

The simulation should clearly demonstrate the hallmark of chaotic systems—sensitivity to initial conditions—while providing controls to explore the rich dynamics of this classic chaotic system.


Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.
















Lorenz Attractor Simulation
Create a JavaScript simulation of the Lorenz attractor demonstrating chaotic behavior in deterministic systems. The simulation should:


Physics Explanation:
The Lorenz attractor models atmospheric convection with three coupled differential equations, producing a strange attractor. It is a classic example of deterministic chaos, showing how tiny differences in initial conditions lead to vastly different outcomes.

Control Parameters:

Sigma (σ): Controls the rate of convection.

Rho (ρ): Relates to temperature difference.

Beta (β): Represents physical properties like fluid viscosity.

Initial Conditions (x, y, z): Set the starting point in phase space.

Time Step/Simulation Speed: Adjust how quickly the system evolves.

General Requirements for All Simulations:

Edge cases (such as energy loss, boundary effects, and numerical instability) must be handled gracefully.

Controls should be intuitive and allow real-time adjustment.

All relevant graphs, values, and formulas must be displayed and update dynamically.

Simulations should be visually engaging and educational, with clear links between controls and observed phenomena.



Physics Implementation:

Implement the Lorenz system of coupled differential equations:

dx/dt = σ(y - x)

dy/dt = x(ρ - z) - y

dz/dt = xy - βz

Use numerical integration (Runge-Kutta method) for accurate solutions

Interactive Features:

Allow adjustment of parameters:

σ (sigma)

ρ (rho)

β (beta)

Enable modification of initial conditions (x₀, y₀, z₀)

Include controls for time step size and visualization speed

Allow rotation and zooming of 3D view

Visualization Components:

Display 3D trajectory with color gradient representing time

Show projections onto x-y, y-z, and x-z planes

Plot time series for each variable (x, y, z)

Graph power spectrum showing frequency distribution

Include phase portraits for different variable combinations

Mathematical Section:

Display the system of differential equations

Show bifurcation diagrams for varying parameters

Include formulas for Lyapunov exponents

Display strange attractor properties

Edge Cases:

Handle parameter regions with different dynamical behaviors

Implement comparison of trajectories with nearby initial conditions

Account for numerical stability in regions of high sensitivity

Visualize transition between order and chaos as parameters change

Technical Recommendations:

Use Three.js for efficient 3D visualization

Implement Web Workers for background computation

Consider WebGL shaders for rendering large numbers of trajectory points

Use adaptive step size methods for numerical integration

The simulation should clearly illustrate the concept of deterministic chaos, strange attractors, and sensitive dependence on initial conditions while providing an intuitive interface for exploring parameter space and visualizing complex dynamics.

Your task:
For the experiment explained above, use the physics explanation and control parameters and all the information attached above, read it carefully and every word of it, to create the JavaScript file as you did before for the other simulations, only this time, I have given you more detail about this experiment and would like for you to generate totally a new file with the same name but as described above. Ensure the simulation is accurate, interactive, and educational, with all controls and visualizations clearly implemented and that they work correctly as expected.